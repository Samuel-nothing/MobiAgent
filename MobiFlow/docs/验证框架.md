## éªŒè¯å·¥ä½œæµå®Œæ•´åˆ†æ
ä»¥ä¸‹æ˜¯å½“å‰æ¡†æ¶ä¸­å®Œæ•´çš„éªŒè¯å·¥ä½œæµï¼š

###  **æ¡†æ¶æ¶æ„æ¦‚è§ˆ**

è¿™æ˜¯ä¸€ä¸ª**åŸºäºDAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰çš„ç§»åŠ¨åº”ç”¨ä»»åŠ¡éªŒè¯æ¡†æ¶**ï¼Œä¸“é—¨ç”¨äºéªŒè¯LLMæ™ºèƒ½ä½“åœ¨ç§»åŠ¨ç«¯æ‰§è¡Œå¤æ‚ä»»åŠ¡çš„å®Œæˆæƒ…å†µã€‚

###  **æ ¸å¿ƒç»„ä»¶ä¸èŒè´£**

#### 1. **æ•°æ®å±‚** (types.py)

- **Frame**: è¡¨ç¤ºæ‰§è¡Œè½¨è¿¹ä¸­çš„ä¸€ä¸ªæ—¶é—´å¸§ï¼ŒåŒ…å«æˆªå›¾ã€XMLã€æ¨ç†ã€åŠ¨ä½œç­‰ä¿¡æ¯
- **TaskSpec**: ä»»åŠ¡é…ç½®è§„èŒƒï¼Œå®šä¹‰èŠ‚ç‚¹ã€ä¾èµ–å…³ç³»å’ŒæˆåŠŸæ¡ä»¶
- **VerifierOptions**: éªŒè¯é€‰é¡¹ï¼Œé…ç½®OCRã€LLMç­‰èƒ½åŠ›
- **VerifyResult**: éªŒè¯ç»“æœï¼ŒåŒ…å«æˆåŠŸçŠ¶æ€ã€åŒ¹é…è·¯å¾„ã€äººå·¥å¤æ ¸æ ‡è®°ç­‰

#### 2. **ä»»åŠ¡åŠ è½½å±‚** (loader.py + trace_loader.py)

- **ä»»åŠ¡é…ç½®åŠ è½½**: ä»YAML/JSONæ–‡ä»¶åŠ è½½ä»»åŠ¡DAGå®šä¹‰
- **è½¨è¿¹æ•°æ®åŠ è½½**: ä»ç›®å½•ç»“æ„æå–å¤šæ¨¡æ€æ•°æ®ï¼ˆå›¾ç‰‡+XML+åŠ¨ä½œ+æ¨ç†ï¼‰
- **æ•°æ®å¢å¼º**: è‡ªåŠ¨ç»„è£…æ–‡æœ¬å­—æ®µï¼Œæ·»åŠ é‚»æ¥ä¸Šä¸‹æ–‡å¼•ç”¨

#### 3. **æ¡ä»¶æ£€æŸ¥å±‚** (conditions.py)

- **åŸºç¡€æ£€æŸ¥å™¨**: `text_match`ã€`regex_match`ã€`ui_flag`ã€`xml_text_match`ã€`action_match`
- **é«˜çº§æ£€æŸ¥å™¨**: 
  - `escalate`: å¤šç­–ç•¥å‡çº§éªŒè¯ï¼ˆtextâ†’regexâ†’uiâ†’xmlâ†’ocrâ†’llmï¼‰
  - `dynamic_match`: åŠ¨æ€æ¡ä»¶åŒ¹é…ï¼Œä»ä»»åŠ¡æè¿°æå–æ¡ä»¶å¹¶éªŒè¯æ“ä½œ
- **æ³¨å†Œæœºåˆ¶**: æ”¯æŒè‡ªå®šä¹‰æ£€æŸ¥å™¨æ‰©å±•

#### 4. **DAGè®¡ç®—å±‚** (dag.py)

- **ä¾èµ–å…³ç³»ç®¡ç†**: æ„å»ºèŠ‚ç‚¹é—´çš„çˆ¶å­å…³ç³»å›¾
- **æ‹“æ‰‘æ’åº**: ç¡®ä¿ä¾èµ–é¡ºåºçš„æ­£ç¡®æ€§
- **ç¯æ£€æµ‹**: éªŒè¯DAGçš„æœ‰æ•ˆæ€§

#### 5. **æ ¸å¿ƒéªŒè¯å±‚** (verifier.py)

verifier:

    - è‹¥èŠ‚ç‚¹å£°æ˜äº† depsï¼Œåˆ™ä»æŒ‰ AND è¯­ä¹‰ï¼ˆå–æ‰€æœ‰ä¾èµ–çš„æœ€æ™šå‘½ä¸­å¸§ä½œä¸ºèµ·ç‚¹ï¼‰
    - è‹¥æœªå£°æ˜ deps ä¸”å­˜åœ¨ next æ¥æºçš„çˆ¶èŠ‚ç‚¹ï¼Œåˆ™æŒ‰ OR è¯­ä¹‰ï¼ˆä»»ä¸€çˆ¶å¯è¡Œå³å¯ï¼Œå–æœ€æ—©å®Œæˆçš„çˆ¶èŠ‚ç‚¹ä½œä¸ºèµ·ç‚¹ï¼‰ å›æº¯æ—¶è®°å½•é€‰æ‹©çš„çˆ¶èŠ‚ç‚¹ï¼Œæ¢å¤å…·ä½“è·¯å¾„


- **å€™é€‰å¸§æ”¶é›†**: ä¸ºæ¯ä¸ªèŠ‚ç‚¹æ”¶é›†æ»¡è¶³æ¡ä»¶çš„å¸§ç´¢å¼•
- **åŠ¨æ€è§„åˆ’ç®—æ³•**: åŸºäºä¾èµ–çº¦æŸè®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å°å¯è¡Œç´¢å¼•
- **è·¯å¾„å›æº¯**: æ„å»ºæœ€ä¼˜æ»¡è¶³è·¯å¾„
- **å¸§ä½¿ç”¨ä¼˜åŒ–**: æ”¯æŒå¸§ç‹¬å å’Œé˜²å›é€€æœºåˆ¶

#### 6. **å¤šæ¨¡æ€å¤„ç†å±‚** (ocr_processor.py)

- **OCRæ–‡å­—è¯†åˆ«**: é›†æˆapp_trajectory_analyzerçš„OCRå¼•æ“
- **æ™ºèƒ½æ–‡æœ¬å¤„ç†**: å¤šæ ¼å¼æ–‡æœ¬é¢„å¤„ç†å’ŒåŒ¹é…ç­–ç•¥
- **XMLæ–‡æœ¬æå–**: ä»Android UI XMLä¸­æå–æ‰€æœ‰å¯è§æ–‡æœ¬
- **é™çº§ç­–ç•¥**: OCRå¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°XMLæ–‡æœ¬æå–

###  **éªŒè¯å·¥ä½œæµè¯¦ç»†æµç¨‹**

#### **é˜¶æ®µ1: æ•°æ®é¢„å¤„ç†**

```python
# 1. åŠ è½½ä»»åŠ¡é…ç½®
task = load_task("task.yaml")  # è§£æDAGèŠ‚ç‚¹å’Œä¾èµ–å…³ç³»

# 2. åŠ è½½æ‰§è¡Œè½¨è¿¹  
frames = load_frames_from_dir("trace_folder/")  # æå–å›¾ç‰‡ã€XMLã€åŠ¨ä½œã€æ¨ç†æ•°æ®

# 3. æ•°æ®å¢å¼º
# - ä¸ºæ¯å¸§æ·»åŠ ç´¢å¼•å’Œä¸Šä¸‹æ–‡å¼•ç”¨
# - ç»„è£…ç»¼åˆæ–‡æœ¬å­—æ®µ
# - æå–UIå…ƒä¿¡æ¯ï¼ˆåŒ…åç­‰ï¼‰
```

#### **é˜¶æ®µ2: DAGä¾èµ–åˆ†æ**

```python
# 1. æ„å»ºDAGå›¾
dag = DAG(task.nodes)  # å»ºç«‹èŠ‚ç‚¹ä¾èµ–å…³ç³»

# 2. æ‹“æ‰‘æ’åº
topo_order = dag.topo_order()  # ç¡®å®šéªŒè¯é¡ºåº

# 3. ç¯æ£€æµ‹
dag._assert_acyclic()  # ç¡®ä¿DAGæœ‰æ•ˆæ€§
```

#### **é˜¶æ®µ3: å¸§åŒ¹é…ä¸å€™é€‰æ”¶é›†**

```python
def _collect_candidates(frames, task, options):
    cand = {}
    used_frames = set()  # å·²ä½¿ç”¨å¸§é›†åˆ
    
    for node in task.nodes:
        hits = []
        checker = get_checker(node.condition.type)
        
        # å¸§ç‹¬å ä¼˜åŒ–ï¼šé¿å…OCR/LLMé‡å¤ä½¿ç”¨åŒä¸€å¸§
        for i, frame in enumerate(frames):
            if needs_exclusive_access(node) and i in used_frames:
                continue
                
            # å¤šç­–ç•¥éªŒè¯
            if checker.check(frame, params, options):
                hits.append(i)
                if needs_exclusive_access(node):
                    used_frames.add(i)
                    break  # æ—©åœæœºåˆ¶
                    
        cand[node.id] = hits
    return cand
```

#### **é˜¶æ®µ4: æ¡ä»¶æ£€æŸ¥ç­–ç•¥**

**4.1 Escalateç­–ç•¥å‡çº§æµç¨‹**:

```yaml
escalation_order: [text, regex, ui, action, dynamic_match, ocr, llm]
```

**4.2 Dynamic MatchåŠ¨æ€æ¡ä»¶æ£€æŸ¥**:

```python
# ä»ä»»åŠ¡æè¿°æå–æ¡ä»¶
if "ä»·æ ¼æœ€ä½" in task_description:
    # åœ¨æ¨ç†æ–‡æœ¬ä¸­éªŒè¯æ˜¯å¦æ‰§è¡Œäº†ä»·æ ¼æ’åº
    verify_in_reasoning("ä»·æ ¼", "ä½åˆ°é«˜", "ä¾¿å®œ")
```

**4.3 OCRå¤šæ¨¡æ€å¤„ç†**:

```python
def frame_ocr(frame):
    # 1. ä¼˜å…ˆä½¿ç”¨OCRè¯†åˆ«å›¾ç‰‡
    if image_exists:
        text = ocr_engine.recognize(image_path)
        if text: return processed_text
    
    # 2. é™çº§åˆ°XMLæ–‡æœ¬æå–
    xml_text = extract_text_from_xml(xml_content)
    return xml_text
```

#### **é˜¶æ®µ5: åŠ¨æ€è§„åˆ’æ±‚è§£**

```python
def verify(frames, task, options):
    # 1. æ”¶é›†å€™é€‰å¸§
    candidates = _collect_candidates(frames, task, options)
    
    # 2. DPè®¡ç®—æœ€å°å¯è¡Œç´¢å¼•
    min_idx = {}
    for node_id in topo_order:
        deps = get_dependencies(node_id)
        
        # ä¾èµ–çº¦æŸï¼šå¿…é¡»æ™šäºæ‰€æœ‰ä¾èµ–èŠ‚ç‚¹
        min_required = max(min_idx[dep] for dep in deps) if deps else 0
        
        # æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³é¡ºåºçº¦æŸçš„å€™é€‰å¸§
        feasible = _min_feasible_index(candidates[node_id], min_required)
        min_idx[node_id] = feasible
    
    # 3. æ£€æŸ¥æˆåŠŸæ¡ä»¶
    success_satisfied = check_success_condition(min_idx, task.success)
    
    # 4. è·¯å¾„å›æº¯
    if success_satisfied:
        path = backtrack_optimal_path(min_idx, task.success)
        return VerifyResult(ok=True, matched=path)
    else:
        return VerifyResult(ok=False, manual_review_needed=True)
```

#### **é˜¶æ®µ6: ç»“æœç”Ÿæˆä¸è·¯å¾„å›æº¯**

```python
# 1. æˆåŠŸè·¯å¾„å›æº¯
if task.success.any_of:
    # é€‰æ‹©æœ€æ—©å®Œæˆçš„æˆåŠŸèŠ‚ç‚¹
    target = min(success_nodes, key=lambda n: min_idx[n])
    path = backtrack(target)
    
elif task.success.all_of:
    # å›æº¯æ‰€æœ‰å¿…éœ€èŠ‚ç‚¹çš„è·¯å¾„
    paths = [backtrack(node) for node in success_nodes]
    path = merge_unique_paths(paths)

# 2. æ„å»ºéªŒè¯ç»“æœ
return VerifyResult(
    ok=True,
    matched=[NodeMatch(node_id=nid, frame_index=idx) for idx, nid in path],
    logs=decision_logs,
    manual_review_needed=False
)
```

###  **å…³é”®åˆ›æ–°ç‰¹æ€§**

#### 1. **æ™ºèƒ½å¸§ç®¡ç†æœºåˆ¶**

- **å¸§ç‹¬å æ¨¡å¼**: OCR/LLMéªŒè¯æ—¶é¿å…å¸§é‡å¤ä½¿ç”¨
- **é˜²å›é€€æœºåˆ¶**: çº¿æ€§æµç¨‹ä¸­é˜²æ­¢å›é€€åˆ°å·²ä½¿ç”¨çš„å¸§
- **æ—©åœä¼˜åŒ–**: æ‰¾åˆ°åŒ¹é…åç«‹å³åœæ­¢ï¼Œæé«˜æ•ˆç‡

#### 2. **å¤šæ¨¡æ€éªŒè¯èƒ½åŠ›**

- **OCRé›†æˆ**: æ”¯æŒPaddleOCRå’ŒTesseractåŒå¼•æ“
- **LLMæ¨ç†**: ç»“åˆæˆªå›¾å’Œä¸Šä¸‹æ–‡çš„å¤šæ¨¡æ€éªŒè¯
- **é™çº§ç­–ç•¥**: OCRå¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°XMLæ–‡æœ¬æå–

#### 3. **åŠ¨æ€æ¡ä»¶åŒ¹é…**

- **ä»»åŠ¡æ„ŸçŸ¥**: ä»ä»»åŠ¡æè¿°è‡ªåŠ¨æå–éªŒè¯æ¡ä»¶
- **æ¨¡å¼æ˜ å°„**: æ”¯æŒå¤æ‚çš„æ¡ä»¶æ¨¡å¼é…ç½®
- **çµæ´»éªŒè¯**: åœ¨å¤šä¸ªå­—æ®µä¸­æŸ¥æ‰¾éªŒè¯å…³é”®è¯

#### 4. **ç­–ç•¥å‡çº§æœºåˆ¶**

- **æ¸è¿›å¼éªŒè¯**: ä»ç®€å•åˆ°å¤æ‚çš„å¤šå±‚çº§æ£€æŸ¥
- **æ™ºèƒ½é™çº§**: é«˜çº§ç­–ç•¥å¤±è´¥æ—¶è‡ªåŠ¨é™çº§
- **é…ç½®é©±åŠ¨**: æ”¯æŒè‡ªå®šä¹‰å‡çº§é¡ºåº

### ğŸ“Š **éªŒè¯ç»“æœç¤ºä¾‹**

```python
VerifyResult(
    ok=True,  # éªŒè¯æˆåŠŸ
    matched=[
        NodeMatch(node_id="open_app_home", frame_index=0),
        NodeMatch(node_id="activate_search", frame_index=1), 
        NodeMatch(node_id="input_keyword", frame_index=2),
        NodeMatch(node_id="submit_search", frame_index=3),
        NodeMatch(node_id="apply_filter_condition", frame_index=4),
        NodeMatch(node_id="add_to_cart", frame_index=6)
    ],
    logs=[...],  # è¯¦ç»†å†³ç­–æ—¥å¿—
    manual_review_needed=False  # æ— éœ€äººå·¥å¤æ ¸
)
```

### ğŸ”§ **æ‰©å±•èƒ½åŠ›**

#### 1. **è‡ªå®šä¹‰æ£€æŸ¥å™¨**

```python
@register_condition("custom_checker")
class CustomChecker(ConditionChecker):
    def check(self, frame, params, options):
        # è‡ªå®šä¹‰éªŒè¯é€»è¾‘
        return custom_logic(frame, params)
```

#### 2. **é…ç½®é©±åŠ¨çš„ä»»åŠ¡å®šä¹‰**

- æ”¯æŒå¤æ‚çš„ä¾èµ–å…³ç³»å®šä¹‰
- çµæ´»çš„æˆåŠŸæ¡ä»¶é…ç½®
- å¯æ‰©å±•çš„æ¡ä»¶å‚æ•°

#### 3. **å¤šç§æ•°æ®æºæ”¯æŒ**

- ç›®å½•ç»“æ„çš„å¤æ‚è½¨è¿¹
- è‡ªå®šä¹‰æ•°æ®æ ¼å¼æ‰©å±•

è¿™ä¸ªæ¡†æ¶ç‰¹åˆ«é€‚åˆéªŒè¯åŒ…å«å¤æ‚ç­›é€‰æ¡ä»¶appæ“ä½œä»»åŠ¡åœºæ™¯ï¼Œèƒ½å¤Ÿæ™ºèƒ½åœ°ä»ä»»åŠ¡æè¿°ä¸­æå–æ¡ä»¶å¹¶éªŒè¯æ˜¯å¦æ­£ç¡®æ‰§è¡Œäº†ç›¸åº”æ“ä½œã€‚
